# -*- coding: utf-8 -*-
"""Customer_churn_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vSDxq027kbD6tf9D7Rj-WxfMqvDOboF6
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score,confusion_matrix,classification_report,roc_auc_score,roc_curve

"""# 1.Problem Statement

2. Data Gathering:
"""

df=pd.read_csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
df

"""# 3. EDA"""

df.isna().sum()

df.info()

df.boxplot()

"""# 4.Feature Engineering"""

df['gender'].unique()

df['gender'].replace({'Female':0,'Male':1},inplace=True)

df['Contract'].unique()

df['Contract'].replace({'Month-to-month':0,'One year':1,'Two year':2},inplace=True)

df['InternetService'].unique()

df['InternetService'].replace({'DSL':0, 'Fiber optic':1, 'No':2},inplace=True)

df['PaymentMethod'].unique()

df['PaymentMethod'].replace({'Electronic check':0, 'Mailed check':1, 'Bank transfer (automatic)':2,
       'Credit card (automatic)':3},inplace=True)

df['Churn'].unique()

df['Churn'].replace({'Yes':0,'No':1},inplace=True)

df['TotalCharges'].dtype

df['TotalCharges'].unique()[:10]

df['TotalCharges'] = pd.to_numeric(df['TotalCharges'], errors='coerce')

df['TotalCharges'].isnull().sum()

df['TotalCharges'].fillna(df['TotalCharges'].median(), inplace=True)

df.info()

"""# 5. Feature Selection"""



df.drop(['customerID','Partner','Dependents','PhoneService','OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport','StreamingTV','StreamingMovies','PaperlessBilling'],axis=1,inplace=True)

df.drop(['MultipleLines'],axis=1, inplace=True)

df.info()

df

corr=df.corr()
corr

sns.heatmap(corr,annot=True)

"""# 6.Model Building:"""

x=df.drop('Churn',axis=1)
y=df['Churn']

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.25,random_state=1,stratify=y)

"""### 1.Logistic Regression"""

from sklearn.linear_model import LogisticRegression
lr=LogisticRegression()
lr.fit(x_train,y_train)

y_pred=lr.predict(x_test)

# Testing Accuracy:

cnf=confusion_matrix(y_test,y_pred)
print("confusion matrix:\n",cnf)
print("Accuracy:",accuracy_score(y_test,y_pred))
print("Classification Report:\n",classification_report(y_test,y_pred))

# Training Accuracy:
y_pred_train=lr.predict(x_train)
cnf=confusion_matrix(y_train,y_pred_train)
print("confusion matrix:\n",cnf)
print("Accuracy:",accuracy_score(y_train,y_pred_train))
print("Classification Report:\n",classification_report(y_train,y_pred_train))

"""2.Decision Tree:"""

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.25,random_state=1,stratify=y)

from sklearn.tree import DecisionTreeClassifier
dt=DecisionTreeClassifier(random_state=1)
dt.fit(x_train,y_train)

# Testing Accuracy:

y_pred=dt.predict(x_test)
cnf=confusion_matrix(y_test,y_pred)
print("confusion matrix:\n",cnf)
print("Accuracy:",accuracy_score(y_test,y_pred))
print("Classification Report:\n",classification_report(y_test,y_pred))

# Training Accuracy:
y_pred_train=dt.predict(x_train)
cnf=confusion_matrix(y_train,y_pred_train)
print("confusion matrix:\n",cnf)
print("Accuracy:",accuracy_score(y_train,y_pred_train))
print("Classification Report:\n",classification_report(y_train,y_pred_train))

"""Random Forest

"""

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.3,random_state=1,stratify=y)

from sklearn.ensemble import RandomForestClassifier
rf=RandomForestClassifier(random_state=1)
rf.fit(x_train,y_train)

# Testing Accuracy:

y_pred=rf.predict(x_test)
cnf=confusion_matrix(y_test,y_pred)
print("confusion matrix:\n",cnf)
print("Accuracy:",accuracy_score(y_test,y_pred))
print("Classification Report:\n",classification_report(y_test,y_pred))

# Training Accuracy:
y_pred_train=rf.predict(x_train)
cnf=confusion_matrix(y_train,y_pred_train)
print("confusion matrix:\n",cnf)
print("Accuracy:",accuracy_score(y_train,y_pred_train))
print("Classification Report:\n",classification_report(y_train,y_pred_train))

"""4. XGboost

"""

from imblearn.over_sampling import SMOTE

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=1,stratify=y)

print("Before SMOTE:\n", y_train.value_counts())

smote = SMOTE(random_state=42)
x_train_sm, y_train_sm = smote.fit_resample(x_train, y_train)

print("\nAfter SMOTE:\n", pd.Series(y_train_sm).value_counts())

from xgboost import XGBClassifier
xgb = XGBClassifier(
    n_estimators=400,
    learning_rate=0.03,
    max_depth=4,
    subsample=0.8,
    colsample_bytree=0.8,
    random_state=42,
    eval_metric='logloss'
)

xgb.fit(x_train_sm, y_train_sm)

y_pred = xgb.predict(x_test)
y_prob = xgb.predict_proba(x_test)[:, 1]

print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("\nAccuracy:", accuracy_score(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

roc_score = roc_auc_score(y_test, y_prob)
print("\nROC-AUC Score:", roc_score)

fpr, tpr, thresholds = roc_curve(y_test, y_prob)

plt.figure(figsize=(6,5))
plt.plot(fpr, tpr, label=f"XGBoost (AUC = {roc_score:.3f})")
plt.plot([0,1], [0,1], linestyle="--")
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve - Customer Churn")
plt.legend()
plt.grid()
plt.show()

from sklearn.model_selection import GridSearchCV

param_grid = {
    "max_depth": [3,4,5],
    "learning_rate": [0.03, 0.05],
    "n_estimators": [300, 400],
    "subsample": [0.8, 1.0]
}

grid = GridSearchCV(
    XGBClassifier(random_state=42, eval_metric='logloss'),
    param_grid,
    cv=3,
    scoring='roc_auc',
    n_jobs=-1
)

grid.fit(x_train_sm, y_train_sm)

print("Best Params:", grid.best_params_)
print("Best ROC-AUC:", grid.best_score_)

df

contract_map = {
    "Month-to-month": 0,
    "One year": 1,
    "Two year": 2
}

internet_map = {
    "DSL": 0,
    "Fiber optic": 1,
    "No": 2
}

gender_map = {
    "Female": 0,
    "Male": 1
}

print("Enter Customer Details")

tenure = int(input("Tenure (months): "))
monthly = float(input("Monthly Charges: "))
total = float(input("Total Charges: "))

contract = input("Contract (Month-to-month / One year / Two year): ")
internet = input("Internet Service (DSL / Fiber optic / No): ")
gender = input("Gender (Female / Male): ")
senior = int(input("Senior Citizen (0 or 1): "))

input_dict = {
    "tenure": tenure,
    "MonthlyCharges": monthly,
    "TotalCharges": total,
    "Contract": contract_map[contract],
    "InternetService": internet_map[internet],
    "gender": gender_map[gender],
    "SeniorCitizen": senior
}

input_df = pd.DataFrame([input_dict])

input_df = input_df.reindex(columns=x.columns, fill_value=0)

pred = xgb.predict(input_df)[0]
prob = xgb.predict_proba(input_df)[0][1]

print("\nPrediction:", pred)
print("Churn Probability:", round(prob, 4))

if pred == 1:
    print("⚠️ Customer likely to CHURN")
else:
    print("✅ Customer likely to STAY")

# Pickling a model : we are packing model here

import pickle

file = open('xgb_model.pkl', 'wb')
pickle.dump(xgb, file)
file.close()

# Unpickling a model : we are unpacking model here.

file = open('xgb_model.pkl', 'rb')
rf_model_new = pickle.load(file)
file.close()

xgb.predict(input_df)



